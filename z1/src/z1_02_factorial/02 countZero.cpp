#include <iostream>
#include <string>
using namespace std;

/*
 阶乘末尾零的个数
 求n！末尾所含0的个数

 5! =  120               末尾1个0
 15! =  1307674368000    末尾3个0

*/

// 方法1
// 以下方法有个缺点：
// long long表示范围2^63-1(19位数)，21！已到20位，溢出后无法准确计算
void test01()
{
    int n;
    cout << "输入一个整型数据：" << endl;
    cin >> n;
    long long res = 1; // 20的阶乘就超过int存储的范围了

    for (int i = 1; i <= n; i++)
    {
        res *= i;
    }
    cout << n << "! = " << res << endl;

    int count = 0; // 计数变量
    while (res % 10 == 0)
    {
        count++;   // 统计0的个数
        res /= 10; // 去个位
    }
    cout << n << "!末尾0的个数为：" << count << endl;
}

/*
方法2
解决long long类型的结果数据溢出的情况

分析思路：
合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数，1既不是合数也不是质数
合数可以拆成多个质数相乘，例如20=2*2*5
末尾为0说明结果数字是合数（不是质数）
质数相乘能产生尾数0的只有2*5

举例：
4 * 25  = 2² * 5² = （2 * 5）²
8 * 125 = 2³ * 5³ = （2 * 5）³

结论：
*   尾数0的个数取决于2和5的因子个数
*   阶乘中每连续的两个数字就会有一个因子2，所以因子2无需考虑，例如5!=5*4*3*2*1，每两个因子提供一个2，4还能提供2个2，6能提供3个2
*   5因子的个数    ——>    阶乘末尾0的个数

注意：
5，10，15，20都只能提供一个5
25能提供2个5
125能提供3个5

优缺点：
优点： 可以计算超过long long类型数字阶乘的末尾0的个数了
缺点： 复杂度高，遍历过程中，无用数字过多
*/

void test02()
{
    int n;
    cout << "输入一个整型数据：" << endl;
    cin >> n;
    // long long res = 1; // 20的阶乘就超过int存储的范围了

    int temp = 0;  // 接收i的临时变量
    int count = 0; // 计数变量

    // 计算阶乘时，统计每一个因子能提供多少个5
    for (int i = 1; i <= n; i++)
    {
        // res *= i;
        temp = i;
        while (temp % 5 == 0)
        {
            count++;
            temp /= 5;
        }
    }

    cout << n << "!末尾0的个数为：" << count << endl;
}

/*
方法3

在解法二的基础上进行优化
无需遍历所有的数字，只需要5的倍数即可

优缺点：
优点：过滤掉阶乘中无用数字的检测
缺点：复杂度高

*/
void test03()
{
    int n;
    cout << "输入一个整型数据：" << endl;
    cin >> n;

    int temp = 0;  // 接收i的临时变量
    int count = 0; // 计数变量

    for (int i = 5; i <= n; i += 5)
    {
        // res *= i;
        temp = i;
        while (temp % 5 == 0)
        {
            count++;
            temp /= 5;
        }
    }

    cout << n << "!末尾0的个数为：" << count << endl;
}

int main()
{
    // test01();
    // test02();
    test03();
    return 0;
}